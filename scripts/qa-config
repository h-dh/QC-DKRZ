#! /bin/bash

##/*! \file qaConfiguration.h
## \brief Parse configuration given by file or command-line

## Priority: command-line statements overwrite all previous
## settings. If a <<t>> -f conf-file<</tt>> and <<t>> -t task-file <</t>>
## are available, then statements in the task-file overrules
## the conf-file. Task-files and config-file are formatted equivalently.\n \n
## Syntax of statements in a configuration file.
## Note: Default values in []\n
## SYNTAX: key[[+]=value[,value[,value,\newline ...]] \n
## -# There are key-words, assignments, comments. Key-words are always
## uppercase. Assignments of multiple values may be given as
## comma-separated lists. A comment is everything following the '#'
## character. Empty lines, and spaces are discarded.
## Notice that the spelling of key-words is not checked. Assignments may
## be anything. Unknown key-words (or typos) are ignored. Significant
## spaces (I hope there are none for CMIP5) have to be escaped by '\'.
## BUT, #this is not implemented. Will be done only on request!
## -# Assignment to a key-word is given by: key-word=value.
## -# Enabling/disabling features is done by assigning t/f to a
## key-word.
## A pure key-word on a text line defaults to true [t]
## e.g. ARITHMETIC_MEAN is equivalent to ARITHMETIC_MEAN=t.
## Disabling by assigning 'f' is equivalent to commenting out.
## -# Multiple line assignments. Multiple assignments must have
## key-word += value. Omittion of '+' overwrites previous assignments.\n
## -# SELECT/LOCK has a special syntax (with [] indicating optional):\n
## SELECT [path1[, path2, ...] = ] [var1[, var2, ...]]\n
## Note: '=' has a special meaning for SELECT; mulitple assignments just add.
## Same for LOCK.
##*/

# ##//! Default setting for some key-words.

setDefaults()
{
  # the comment 'export' denotes keywords which must be submitted
  # to the calling qaDirector

  # you should not leave this unchanged in the config file
  test ! ${QA_RESULTS} && setKWL QA_RESULTS=${QA_HOME/%.qa-dkrz}/QA_Results

  setKWL QA_HOST=$HOSTNAME

  setKWL QA_BIN=${HOSTNAME}:${QA_SRC}/bin

  # A list of machines executing asynchronous jobs.
  setKWL QA_EXEC_HOSTS=$HOSTNAME

  # If a process cannot be run, because e.g. the data base
  # is not available or a server is absent, then, after a
  # sleep, retry. But only for the number of times spefied below.
  setKWL REATTEMPT_LIMIT=5 # export

  # In order to enable trapping signals, long sleeping period are
  # subdivided into smaller intervals of consecutive sleep commands.
  setKWL HARD_SLEEP_PERIOD=10        # [s] export

  # if not there then 'mail' will be set after a successful check
  setKWL MAIL=mailx

# List of number(s) of simultaneous entity of executors per host.
# This is a friendly act against your colleagues.
# Special: the one and only number is assigned to all QA_EXEC_HOSTS.
# Fine tuning: each positional number in the list corresponds to a
# position in the QA_EXEC_HOSTS list. If less positions are given
# than in QA_EXEC_HOSTS, then the last position is assigned to
# the omitted positions.
  setKWL NUM_EXEC_THREADS=1

  setKWL SLEEP_PERIOD=300            # [s] export
}

add2qaConf()
{
  local prospect=$1

  if [ ${prospect:0:2} = './' ] ; then
    prospect=${prospect:2}
  elif [ ${prospect:0:3} = '../' ] ; then
    local myPwd=$(pwd)
    prospect=${myPwd%/*}/${prospect:3}
  fi

  # found a name
  # test whether this name was already specified
  for(( i=0 ; i < ${#filePrecedence[*]} ; ++i )) ; do
    test "${filePrecedence[i]}" = "${prospect}" && return 1
  done

  filePrecedence[${#filePrecedence[*]}]=${prospect}

  return 0
}

changeGroupPermission()
{
  local sendText

  # Give permissions to all group members
  if [ ${GROUP_NAME} ] ; then
    # change to new group name
    item=$( ls -ld $1 | awk '{print $4}' )
    if [ "$item" != "$GROUP_NAME" ] ; then
      if ! chgrp -R $GROUP_NAME $1 &> /dev/null ; then
        std_out "${0##*/}::changeGroupPermission(): chgrp "
        std_out "Invalid group or you are probably not allowed to change group."
        std_out "If so, please ask your admin to chgrp -R $GROUP_NAME $1"
        std_out flush
        exit 1
      fi
    fi

    # set SGID bit
    item=$( ls -ld $1 | awk '{print $1}' )
    if [ ! "${#sendText}" -a ${item:6:1} != s ] ; then
      # It would be amazing if chmod would not be allowed, but chgrp was
      find $1 -type d -exec chmod g+srwx {} \;
      find $1 -type f -exec $QA_SRC/scripts/cpMod {} \;
    fi
  fi
}

##//! Check availabillity of tools.

checkTools()
{
  local sendText  # failed checks will accumulate text
  local isExit=f;
  local str

  # check only tools, display, and exit
  CHECK_TOOLS=${CHECK_TOOLS:-f}

  # we know that it's bash

  if [ $CHECK_TOOLS = t ] ; then
    if [ ! -e $QA_SRC ] ; then
      std_out "$QA_SRC\t\t directory not found"
    else
      std_out "QA_SRC\t\t $QA_SRC"
    fi
  fi

  # all machines must share the same file system

  # invoke execution paths
  local bin l nnn
  for(( l=0 ; l < ${#QA_BIN[*]} ; ++l )) ; do
    bin=${QA_BIN[l]}
    bin=${bin%/}  # rm trailing '/'
    if ! mkdir -p ${bin#*:} &> /dev/null ; then
       std_out "Fatal error: could not mkdir ${bin#*:}"
    fi

    # valid on the qa-DKRZ host
    if [ "${bin#*:}" = "${bin}" ] ; then
      PATH=${bin}:$PATH  # this is 'imported' by qa-DKRZ
    elif [ "${bin%:*}" = "${HOSTNAME}" ] ; then
      PATH=${bin#*:}:$PATH  # this is 'imported' by qa-DKRZ
    fi
  done

  # test initial existance of some basic commands

  if [ ${CHECKSUM} ] ; then
    local cs
    if [ ${CHECKSUM} = t ] ; then
      cs=md5
    else
      cs=${CHECKSUM%sum}
    fi

    if [ ! -x $cs ] ; then
      if tryExist com ${cs}sum ; then
         test $CHECK_TOOLS = t && std_out "${cs}sum\t\t available"
      else
         str="${cs}sum\t\t not found; switch to md5sum."
         test $CHECK_TOOLS = t && std_out "$str"
         CHECKSUM=md5
      fi
    fi
  fi

  if [ ${#EMAIL_TO[*]} -gt 0 ] ; then
    # try mailx
    if tryExist com ${MAIL} void ; then
      test $CHECK_TOOLS = t && std_out "${MAIL}\t\t available"
    else
      MAIL=mail
      if tryExist com ${MAIL}  ; then
        test $CHECK_TOOLS = t && std_out "${MAIL}\t\t available"
      else
        EMAIL_TO=
        str="${MAIL}(x)\t\t not found; email notification disabled"
        test $CHECK_TOOLS = t && std_out "$str"
      fi
    fi
  fi

  if [ ${HLEVD} ] ; then
    if tryExist com cdo ; then
      test $CHECK_TOOLS = t && std_out "cdo\t\t available"
    else
      std_out "cdo\t\t not found; disable HLEV."
      std_out "\t\tHLEVD is disabled."
      std_out "\t\tTo make it run, please, install CDO in PATH."
    fi
  fi

  # a few simple commands: exclude bc ssh
  # below: awk expt
  local cmd
  for cmd in basename 'date +\'%F%T'' \
             git grep kill ls mkdir mv sed rm sleep test
  do
    if tryExist com $cmd ; then
      test $CHECK_TOOLS = t && std_out "${cmd}\t\t available"
    else
      isExit=t ;
      std_out "command: ${cmd}\t\t not available"
    fi
  done

  if  which awk &> /dev/null || which gawk &> /dev/null ; then
     test $CHECK_TOOLS = t && std_out "(g)awk\t\t available"
  else
     isExit=t ;
     std_out "(g)awk\t\t not available"
  fi

  if which expr &> /dev/null ; then
     if expr match asdf234 '.*f\([[:digit:]]*\)' &> /dev/null ; then
       test $CHECK_TOOLS = t && std_out "expr\t\t available"
     else
       sendText="${sendText}\nexpr match asdf234 \'.*f\([[:digit:]]*\)\': no"
       isExit=t ;
       std_out "expr\t\t available, but not working"
     fi
  else
     isExit=t ;
     std_out "expr\t\t not available"
  fi

  # no email notification
  test ${CHECK_TOOLS} = t && exit 1

  if [ ${isExit} = t ] ; then
    std_out flush
    exit 1
  fi
}

##//! Description of usage on the terminal

##/*!
## In case of --help or invalid command-line argument.
##*/

descript()
{
  local com localDev text

  if [ -c "${TTY}" ] ; then
    # output to a terminal
    com=cat
    localDev="> $TTY"
  else
    # EMail
    if [ ${#EMAIL_TO[*]} -gt 0 ] ; then
      if which mail &> /dev/null ; then
        com="mail -s $sendSubject ${EMAIL_TO[*]}"
      elif which mailx &> /dev/null ; then
        com="mailx -s $sendSubject ${EMAIL_TO[*]}"
      fi
    elif [ ${SESSION_LOGDIR}  ] ; then
       # session log-file
       com=cat
       localDev='>> $SESSION_LOGDIR/session.log'
    elif [ ${QA_SRC} ] ; then
      # NoDevice
      local str0
      str0="undeliv_$( date +'%FT%T' )_${HOSTNAME%%.*}".txt
      if mkdir -p $QA_SRC/NoDevice &> /dev/null ; then
        com=cat
        localDev='>> ${QA_SRC}/NoDevice/$str0'
      fi
    fi
  fi

  # provide text for -E_ enabled option description
  local enableOptText
  displayComLineOptions # text appended below


  eval $com $localDev <<!
$sendText

Usage: qa-DKRZ options

  Quality Control of file system based ${PROJECT} experiments.

  QA for file system (FS) based data of climatological experiments
  contained in netCDF files.
  The QA builds directories for storage of check-log files, session
  annotations and time series (netCDF) of QA specific data. The
  latter is given in a directory tree similar to the one of the original
  data, i.e. arranged for variables and the corresponding frequency.
  The logfiles for checked experiments are stored within directory
  'check_logs', which contain sub-dirs _Notes and _Periods for
  annotations of failed checks and checked time-range, respectively.
  Please, have a look at QA-DKRZ/doc/qa-user-manual.pdf for more details.

  A run is usually started by executing:
     path/QA-DKRZ/scripts/qa-DKRZ options
  where options contain usually -c 'file' and/or -f 'file' for
  one or two configuration files.
  A configuration file with processing directives may contain a link
  to another configuration file with lower priority; there is no
  maximal nesting depth.

  Assignments on the command-line may overwrite those of
  the configuration file. However, most of command-line options
  are for short-term purposes (debugging, displaying status etc.).
  Usage of configuration file(s) is recommended.
  Each configuration assignment may be given on the command-line, but
  prefixed by '-E_'.

  Regular Expressions are permitted as applicable to the 'expr' command.
  Definition: A list is comma-separated in a single string.

  Usually key-words will be given only once, but are overruled
  corresponding to the priority of configuration files; but
  assignments could be appended by '+='.

  Assignments ot key words SELECT and LOCK exhibit identical,
  but specific behaviour. The assignment character '=' is replaced
  by a space. However, continuation of assignments (appending) is
  done with '+=*. SELECT and LOCK, respectively, may be substituted
  by -S and -L on the command-line.
  Syntax: [path1[,path2,...]]=[var1[,var2,...]]
  Examples ('path' denotes a sub-path continuing the
  one in PROJECT/DATA, 'var' inidcates a starting sub-string for
  file names [e.g. tas_.*day]):
  1) path=var
     specifies a path where to look for a single variable; the path
     may fork to and continue with several sub-paths (e.g. for frequencies).
  2) p1,p2=var
     two paths to look for a variable.
  3) a) p1=
     b) p1,p2=
     one and two paths, respectively, with every variable;
     equivalent to p1,p2=.*
  4) p1=v1,v2
     one path [in the sense of 1)] with two variables.
  5) var[,v2,v3]
     specified variables in every path.
  6) p1=,p2=v1...  --> This is an ERROR.
  7) no '=' character
     a) not a path: variable(s) in all sub-paths prolonging the one
        in PROJECT_DATA, equivalent to '.*', e.g.
        by -S var on the command-line.
     b) contains at least a single '/' character; this is
        equivalent to 3a).

  But, if you want to make a run only for a specific variable
  or a group of entries using Regular Expression, then using
  the command-line is reasonable. Also some features are only
  enabled via the command-line, e.g. -E_DEBUG_... .

  Options:
   -E_...    Enable where ... indicates a configuration directive.
             An key-word with appended '=' character expects a value;
             items without assignments are boolean switches (t or f) where
             a key-word without any assign,ment expands to (t).
             Detailed description is given in file
             QA-DKRZ/example/CORDEX_qa.conf .
   -f name   Read configuration.
             Note: one configuration file may contain frequently
             modified assignments while the other hold all time
             assignments. If a name without leading path component
             is not available locally, then QA-DKRZ/tables is searched.
             Note: files for -c and -f are arbitrarily convertible.
   -h/--help This description.
   -L        Locking of paths and variables
   -m        Monitor variable name most recently qa'ed in status line.
   -P        Project name (usually PROJECT= in a config-file).
   -S        Selection of paths and variables (see config-file).
   -x        Equivalent to -E_DEBUG_C -E_DEBUG_E -E_DEBUG_M.
   --auto-up[=disable]
             Permanently enable/disable automatic svn updates:
             no assigment enables, disabling by: --auto-up=d or --auto-up=disable .
   --pb[=filename[,step]]
             Progress bar properties.
             Output of number of processed data files and total number of data files;
             if a filename is not provided, then to stdout. Note that stdout should be
             redirected if option -m is also active. The step defines the stepping rate
             of the output in terms of percentage; 1% by default.
             Note that a filename must contain at least a single alpha char and
             that the step must not.
   --project_as=string
             The current PROJECT is treated as PROJECT=string, but with
             the name kept.
   --qa-work-dir  Path to tables, .qa-config file (if no \$HOME dirctory is
             accessible), and a CF_TestSuite.
             There are two defaults depending on the way the QA-DKRZ package
             was fetched:
               a) user's \$HOME for a miniconda-built package.
               b) package path if cloned from GitHub and the install script is applied.
             qa-work-dir is also the location of check results
             if the QA_RESULTS option is omitted.

${enableOptText}
!
  exit 1
}

displayComLineOptions()
{
      enableOptText="\

      Additional options usually enabled on the command-line:
      CHECK_TOOLS           Check and show availability of tools and exit.
      DEBUG_C[ONFIGURATOR]  Log qaConfiguration processing to stderr.
      DEBUG_E[XECUTOR]      Log qaExecutor processing to files corresponding to
                            variable names (where qa-DKRZ was started).
      DEBUG_M[ANAGER]       Execution log of the qa-DKRZ to stderr.
      DEBUG_X[=script]      Enable debugging of external script; default all.
      FLOW_TRACE            Flow trace analysis of the qa-DKRZ main-loop.
                            Note that specific commenting-in is required.
      NEXT[=num]            Process the next num variables.
      ONLY_SUMMARY          Post-processed by default when ever a check
                            was performed (usually not necessary, because
                            this is performed at the end of a run).
      SHOW_CALL             Show the qA_main.x call; no execution.
      SHOW_CONF             Show configuration and exit.
      SHOW_EXP              Show names of paths with scheduled variables.
      SHOW_NEXT[=num}       Show num next scheduled variables and paths.
      REFRESH_CF_STANDARD   wget original sources from PCMDI into QA-DKRZ/tables.
      REUSE_PATH_LIST       Use a path-list left previously for a resumed session.
"

  test $# -eq 0 && return

  if [ -c "$TTY" ] ; then
    echo '' > $TTY
    cat > $TTY <<!
$enableOptText
!
  fi

}

findEmbeddedConf()
{
  local currConf=$1

  # Is there a QA_CONFIG assignment embedded in the current file?
  # This separates commented-out from enabled QA_CONF assignment
  # If fails, then try a backward comatibel approach
  local item names name
  names=( QA_CONF QC_CONF qa_conf qc_conf )

  for name in ${names[*]} ; do
    item="$(grep ${name}= ${currConf} 2> /dev/null )"
    item="${item// /}"
    item=( ${item} )           # several lines are possible
    item=( ${item[*]%%\#*} )
    item=( ${item[*]} )
    item=${item#${name}=}

    test ${item} && break
  done

  # when item is empty, but a PROJECT or PORJECT_AS is going to be
  # found, then use this
  findProject $currConf

  if [ ! "${item}" ] ; then
     if [ ${PROJECT_AS} ] ; then
       item=${PROJECT_AS}_qa.conf
     elif [ ${PROJECT} ] ; then
       item=${PROJECT}_qa.conf
     else
       return
     fi
  fi

  local ix p
  local pDir  # index 0 -> 3 provides precedence

  if [ ${item} != ${item##*/} ] ; then
    pDir[0]=${item%/*}/  # absolute path
    item=${item##*/}
  else
    pDir[0]=$(pwd)/  # local path
  fi

  # backward compatibility: qc
  local pos
  if findStr ${item} _qc pos ; then
    local item_alt=${item:0:pos}_qa${item:$((pos+3))}
  fi

  pDir[1]=${QA_HOME}/tables/
  pDir[2]=${QA_HOME}/tables/${item%_*}/
  pDir[3]=${QA_HOME}/tables/projects/
  pDir[4]=${QA_HOME}/tables/projects/${item%_*}/
  local ix

  local items
  declare -a items
  items=( ${item} ${item_alt} )

  for(( ix=0 ; ix < 5 ; ++ix )) ; do
    for item in ${items[*]} ; do
      if [ -f ${pDir[ix]}${item} ] ; then
        if add2qaConf ${pDir[ix]}${item} ; then
          findEmbeddedConf ${pDir[ix]}${item}
        fi
        break
      fi
    done
  done

  return
}

findProject()
{
  # 1. Scan files for explicit PROJECT and PROJECT_AS specifications.
  # 2. Try to identify known default projects names in the filename.

  local currConf=$1
  local prj

  # look for a specification in the current conf-files.
  local name arg val
  declare -a name arg
  name=
  arg=

  for prj in PROJECT PROJECT_AS ; do
    val=( $(grep "^[[:space:]]*[^#][[:space:]]*${prj:1}=" ${currConf} ) )
    if [ "${val}" ] ; then
      name[${#name[*]}]=${val%=*}
      arg[${#arg[*]}]=${val#*=}
    fi
  done

  # only if not set previously
  if [ !${PROJECT_AS} ] ; then
    local i
    for i in 0 1 ; do
      if [ "${name[i]}" = PROJECT_AS ] ; then
        setKWL PROJECT_AS=${arg[i]}
        return
      fi
    done

    for i in 0 1 ; do
      if [ "${name[i]}" = PROJECT ] ; then
        setKWL PROJECT_AS=${arg[i]}
        return
      fi
    done
  fi

  if [ "${PROJECT_AS}" ] ; then
    return # PROJECT may be unset
  else
    # find known project names
    if [ ${#knownProjects[*]} -eq 0 ] ; then
      knownProjects=( $( ls ${QA_HOME}/tables/projects) )
    fi

    # filename with a leading project name?
    local item
    for prj in ${knownProjects[*]} ; do
      item=${currConf##*/}
      if [ ${prj} = ${item:0:${#prj}} ] ; then
        break
      else
        prj=
      fi
    done

    test ${prj} && setKWL PROJECT_AS=$prj
  fi

  return
}

findStr()
{
  test ${DEBUG_CONF} && voidX

  # find position of sub-string in string
  # $1: the string
  # $2: sub-string to find
  # $3: 'return' the position, if $3 exists

  local i
  local len=${#2}
  local end=$(( ${#1} - len + 1 ))

  for(( i=0 ; i < end ; ++i )) ; do
    if [ "${1:i:len}" = "$2" ] ; then
      test ${#3} -gt 0 && eval ${3}=$i
      test ${DEBUG_CONF} && voidX
      return 0
    fi
  done

  test ${DEBUG_CONF} && voidX
  return 1
}

getMultiLists()
{
  # note that a CF_check-list.conf file may be given in every project.
  # The rules given within would overwrite default CF ones.

  local pDir  # index 0 -> 3 provides precedence

  pDir[0]=$(pwd)  # local path
  pDir[1]=${QA_HOME}/tables
  pDir[2]=${QA_HOME}/tables/${PROJECT}
  pDir[3]=${QA_HOME}/tables/projects/${PROJECT}

  local prjList cfList
  declare -a prjList cfList

  # precedence of check lists: user-defined --> default
  local fs=( CF_check-list.conf ${PROJECT}_check-list.conf)

  local p
  for p in ${pDir[*]} ; do
    test -f $p/${fs[0]} && cfList[${#cfList[*]}]=$p/${fs[0]}
    test -f $p/${fs[1]} && prjList[${#prjList[*]}]=$p/${fs[1]}
  done

  p=${QA_HOME}/tables/projects/CF
  test -f $p/${fs[0]} && cfList[${#cfList[*]}]=$p/${fs[0]}

  if [ $# -gt 0 ] ; then
    # notes provided on the command-line;
    # there are two types possible: one for CF the other for the project

    set +B # disable brace expansion
    local a arg cf_CL prj_CL isCF isPRJ
    declare -a cf_CL prj_CL

    for arg in $* ; do
      if findStr ${arg} CF_ ; then
        if [ ${isCF:-f} = f  ] ; then
          local cl_CF_note=/tmp/CF_comLineNote_$$.txt
          isCF=t
        fi

        # multiple notes could be given aus comma-sep-braces;
        # print each note on a separate line of the file
        arg="${arg#*=}"
        arg=( ${arg//\},/\} } )
        for a in ${arg[*]} ; do
          echo "text & ${a}" >> /tmp/CF_comLineNote_$$.txt
        done
      else
        if [ ${isPRJ:-f} = f  ] ; then
          local cl_PRJ_note=/tmp/PRJ_comLineNote_$$.txt
          isPRJ=t
        fi

        # multiple notes could be given aus comma-sep-braces;
        # print each note on a separate line of the file
        arg="${arg#*=}"
        arg=( ${arg//\},/\} } )
        for a in ${arg[*]} ; do
          echo "text & ${a}" >> /tmp/PRJ_comLineNote_$$.txt
        done
      fi
    done

    set -B
  fi

  local cf="${cl_CF_note}${cl_CF_note:+ }${cfList[*]}"
  local prj="${cl_PRJ_note}${cl_PRJ_note:+ }${prjList[*]}"

  setKWL CF_CHECK_LIST="${cf// /,}"
  setKWL QA_CHECK_LIST="${prj// /,}"

  return
}

getPrecedence()
{
  filePrecedence=( $* )

  # the first two items of array 'task_priority' would have been
  # set while performing getops().

  local i item qaResults swp sz1 sz

  # in case there are multiple conf files, then 'task' files followed by
  # the sequence of embedded QA_CONF assignments get
  # priority with the order the task-files are specified.
  sz1=$(( ${#filePrecedence[*]} -1 ))
  sz=${#filePrecedence[*]}
  local i1 i2

  for(( i1=0 ; i1 < sz1 ; ++i1 )) ; do
    for((i2=i1+1 ; i2 < sz ; ++i2 )) ; do
      if [ "${filePrecedence[i1]##*.}" != task -a "${filePrecedence[i2]##*.}" = task ] ; then
      swp=${filePrecedence[i1]}
      filePrecedence[${i1}]=${filePrecedence[i2]}
      filePrecedence[${i2}]=${swp}
    fi
    done
  done

  # resolve relative paths
  for(( i1=0 ; i1 < sz ; ++i1 )) ; do
    if [ ${filePrecedence[i1]:0:2} = './' ] ; then
      filePrecedence[i1]=${filePrecedence[i1]:2}
    elif [ ${filePrecedence[i1]:0:3} = '../' ] ; then
      item=$(pwd)
      item=${item%/*}
      filePrecedence[i1]=${item}/${filePrecedence[i1]:3}
    fi
  done

  # This loop only works for filenames passed as parameters.
  # Go through the chain of files unless no more
  # is found or a path found before is found again;
  # an invalid file would also break processing
  local j

  for(( i=0 ; i < sz ; ++i )) ; do
    # attach a chain of embedded conf-files
    # sets also PROJECT if found in the sequence of conf-files.
    if ! add2qaConf ${filePrecedence[i]} ; then
      findEmbeddedConf ${filePrecedence[i]}
    fi
  done

  return
}

getCurrPaths()
{
  # where all the work is going to take place
  if [ $QA_HOME ] ; then
    test ! -d $QA_HOME/.qa-dkrz && mkdir -p $QA_HOME/.qa-dkrz 2> /dev/null
  else
    setKWL QA_HOME=~/.qa-dkrz
  fi

  # the config filename and location
  if [ -w ~ ] ; then
    local cPath=~/.qa-dkrz
    test ! -d $cPath && mkdir -p $cPath 2> /dev/null
    setKWL CONFIG_FILE=$cPath/config.txt

  elif [ -w "$QA_SRC" ] ; then
    test ! -d $QA_SRC/.qa-dkrz && mkdir -p $QA_SRC/.qa-dkrz 2> /dev/null
    setKWL CONFIG_FILE=$QA_SRC/.qa-dkrz/conf.txt

  elif [ -w "$QA_HOME" ] ; then
    test ! -d $QA_HOME && mkdir -p $QA_HOME/.qa-dkrz 2> /dev/null
    setKWL CONFIG_FILE=$QA_HOME/config.txt

  else
    std_out "${0##*/}::getCurrPaths():"
    std_out "HOME and QA_DKRZ without write permissions,"
    std_out "please restart with provided option --workspace=str"
    std_out flush
    exit 1
  fi

  # the paths
  test ! $QA_HOME && setKWL QA_HOME=~/.qa-dkrz

  test ! -d $QA_HOME     && mkdir -p $QA_HOME 2> /dev/null

  return
}

getQA_SRC()
{
  # extract the path to the root of the QA package

  # is it in a conda built?
  local x_conda=${0%/qa-dkrz}
  if [ ${x_conda##*/} = bin ] ; then
    x_conda=${x_conda%/bin}
    if [ -d $x_conda/opt/qa-dkrz ] ; then
       setKWL CONDA_ENV=t
       setKWL QA_SRC=$x_conda/opt/qa-dkrz
       return
    fi
  fi

  local target isInvalid

  if [ ${1:0:1} = '/' ] ; then
    target=$1
  else
    target=$(pwd)/$1
  fi

  if [ -h $target ] ; then

    # get the link
    local link=$(ls -l $target | awk  '{print $(NF)}')

    # link is relative, so make it absolute
    test ${link:0:1} != '/' && link=${target%/*}/${link}

    getQA_SRC ${link}

  elif [ -f $target ] ; then

    # a real instance, at first resolve .. and .
    # works also for . or .. in the middle of the path

    local xname=${target##*/}
    target=${target%/*}  # remove the name of the script

    local arr=( ${target//\// } )

    local i j sz
    sz=${#arr[*]}

    for(( i=1 ; i < sz ; ++i )) ; do

      if [ "${arr[i]}" = '.' ] ; then
        unset arr[i]
      elif [ "${arr[i]}" = '..' ] ; then
        j=$((i-1))

        # this takes into account adjacent . and/or .. with any depth
        while [ ! ${arr[j]} ] ; do
          j=$((j-1))
        done
        unset arr[j]
        unset arr[i]
      fi
    done

    # get rid of empty items
    arr=( ${arr[*]} )

    sz=${#arr[*]}

    local tmp
    for(( i=0 ; i < sz ; ++i )) ; do
      tmp=${tmp}/${arr[i]}

      if [ -f ${tmp}/.install_configure ] ; then
        QA_SRC=$tmp
        break
      fi
    done

    test $i -eq $sz && isInvalid=t
  else
    isInvalid=t
  fi

  if [ ${isInvalid:-f} = t ] ; then

    local str=$(ls -l $target 2> /dev/null | awk  '{print $(NF)}')

    if [ ${str} ] ; then
      str="invalid path=$0"
    else
      str="broken path=$0"
    fi

    std_out "${0##*/}::getQA_SRC():"
    std_out "$str"
    std_out flush
    exit 1
  fi

  setKWL QA_SRC=${QA_SRC}

  return
}

initSession()
{
  # Create sub-dir structure for different logs, but
  # the check_logs. md5sum checksums of conf and task
  # (all may be omitted and substituted by '-') are written to a file.
  # Specific command-line options (SHOW_*)
  # will write 'test_session', i.e. set RESUME_SESSION=f.
  # A session is definded by conf and task files given
  # in array QA_CONF.
  # When all checkums of the current files are found in a previous session,
  # then the latter is resumed, i.e. RESUME_SESSION=t.
  # Explicit RESUME_SESSION=f disables.

  # base path to sessions
  test ! -d ${QA_RESULTS}/session_logs && mkdir -p ${QA_RESULTS}/session_logs

  setKWL RESUME_SESSION=t  # by default

  # force a new session, although resuming would be possible
  test ${FORCE_NEW_SESSION:-f} = t && setKWL RESUME_SESSION=f

  # find test-cases from command-line options
  local i j cl testCase

  for(( i=0 ; i < ${#comLine[*]} ; ++i )) ; do
    cl=${comLine[i]}

    test ${cl:0:7} = '-E_SHOW'  \
        && testCase=t \
             && setKWL RESUME_SESSION=f \
                 && break
  done

  # current checksums; note: md5sum ouputs two items: checksum and filename
  # (filename is substituted by '-' for reading from input)
  local curr_md5
  declare -a curr_md5
  local currDate=$( date +'%F_%T' )

  local qaC qaCs
  qaCs=( ${QA_CONFS[*]//,/ } )

  if [ ${#qaCs[*]} -gt 0 ] ; then
    for qaC in ${qaCs[*]}  ; do
      curr_md5=( ${curr_md5[*]} $( md5sum $qaC | awk '{print $1}') )
    done
  else
    curr_md5=( '-' )
  fi

  # test for resuming a session
  if [ ${RESUME_SESSION} = t ] ; then
    local k l sDates
    local dates0 dates1
    declare -a dates0 dates1

    # look for a previous identical session given in file sess_md5.txt
    if [ -f ${QA_RESULTS}/session_logs/sess_md5.txt ] ; then
      # first item is a date, second is a checksum.
      dates0=( $(grep "${curr_md5[0]}" \
                ${QA_RESULTS}/session_logs/sess_md5.txt 2> /dev/null \
                | awk '{print $1}' ) )

      for(( k=1 ; k < ${#qaCs[*]} ; ++k )) ; do
        dates1=( $(grep "${curr_md5[k]}" \
                 ${QA_RESULTS}/session_logs/sess_md5.txt 2> /dev/null \
                 |  awk '{print $1}' ) )

        for(( i=${#dates0[*]}-1 ; i >-1 ; --i )) ; do
          for(( j=0 ; j < ${#dates1[*]} ; ++j )) ; do
            # compare to the date of another conf/task file
            if [ ${dates0[i]} = ${dates1[j]} ] ; then
              continue 2
            fi
          done
          unset dates0[${i}]
        done
      done

      dates0=( ${dates0[*]} )  # remove empty items

      if [ ${#dates0[*]} -eq 1 ] ; then
        setKWL SESSION=${dates0[0]}
      else
        local is=t
        for(( j=1 ; j < ${#dates0[*]} ; ++j )) ; do
          test ${dates0[0]} != ${dates0[j]} && is=f
        done
        test $is = f -o ${#dates0[*]} -eq 0 && setKWL RESUME_SESSION=f
      fi
    else
      setKWL RESUME_SESSION=f
    fi
  else
    if [ ${testCase:-f} = t ] ; then
      setKWL SESSION=test_session
      test -d ${QA_RESULTS}/session_logs/test_session && \
         \rm -r ${QA_RESULTS}/session_logs/test_session
    fi

    setKWL RESUME_SESSION=f
  fi

  # session date wasn't set externally.
  if [ ${RESUME_SESSION} = f -a ${testCase:-f} = f ] ; then
    for(( k=0 ; k < ${#qaCs[*]} ; ++k )) ; do
      # write a new entry for each conf/task file
      echo -e -n "${currDate}\t" \
             >> ${QA_RESULTS}/session_logs/sess_md5.txt
      echo -e -n "${curr_md5[k]}\t" \
             >> ${QA_RESULTS}/session_logs/sess_md5.txt
      echo       "${qaCs[k]}" \
             >> ${QA_RESULTS}/session_logs/sess_md5.txt
    done

    setKWL SESSION=${currDate}
  fi

  setKWL SESSION_LOGDIR=${QA_RESULTS}/session_logs/${SESSION}
  mkdir -p ${SESSION_LOGDIR}

  return
}

loadSetting()
{
  local tmp

  if [ ! ${QA_SRC} ] ; then
    sendSubject='QA: initialisation error'
    std_out "QA_SRC must be set. Exit."
    std_out flush
    exit 1
  fi

  if [ ! -d "$QA_SRC" ] ; then
    sendSubject='QA: initialisation error'
    std_out "Source dir $QA_SRC must exist and must be writable. Exit."
    std_out flush
    exit 1
  fi

  tmp=(${PROJECT_DATA[*]//,/ })
  tmp=(${tmp[*]%/})  # rm trailing '/'

  # completion of relative paths
  for(( i=0 ; i < ${#tmp[*]} ; ++i )) do
    test ${tmp[i]:0:1} = '/' && continue

    if [ ${tmp[i]:0:2} = './'  ] ; then
      tmp[${i}]=$(pwd)${tmp[i]:1}
    elif [ ${tmp[i]:0:3} = '../'  ] ; then
      myPwd=$(pwd)
      tmp[${i}]=${myPwd%/*}${tmp[i]:2}
    else
      tmp[${i}]=$(pwd)/${tmp[i]}
    fi
  done

  tmp="${tmp[*]}"
  PROJECT_DATA=${tmp// /,}

  QA_SRC=${QA_SRC%/}  # rm trailing '/'

  QA_RESULTS=${QA_RESULTS%/}  # rm trailing '/'
  if [ ${QA_RESULTS:0:1} != '/' ] ; then
    if [ ${QA_RESULTS:0:2} = './'  ] ; then
      QA_RESULTS=$(pwd)${QA_RESULTS:1}
    elif [ ${QA_RESULTS:0:3} = '../'  ] ; then
      myPwd=$(pwd)
      QA_RESULTS=${myPwd%/*}${QA_RESULTS:2}
    else
      QA_RESULTS=$(pwd)/${QA_RESULTS}
    fi
  fi

  for pD in ${PROJECT_DATA[*]//,/ } ; do
    if [ ! -d "$pD" ] ; then
      std_out "PROJECT_DATA: $pD not found"
      std_out flush
      exit 1
    fi

    if [ "$pD" = "$QA_RESULTS" ] ; then
      # this must not happen
      sendSubject='QA: configuration error'
      std_out "Conflict: QA_RESULTS and PROJECT_DATA are identical. Exit."
      std_out flush
      exit 1
    fi

  done


  if [ ! ${PROJECT_DATA} ]  ; then
    local isRoot=t
    for(( i=0 ; i < ${#pathList[*]} ; ++i )) ; do
      test ${pathList[i]:0:1} != '/' && isRoot=f && break
    done

    if [ ${isRoot} = t ] ; then
      # get it from SELECT with absolute path
      for(( i=0 ; i < ${#pathList[*]} ; ++i )) ; do
        test ${PROJECT_DATA} && PROJECT_DATA="${PROJECT_DATA},"

        PROJECT_DATA="${PROJECT_DATA}${pathList[i]%/*}"
        pathList[i]=${pathList[i]##*/}
      done

      setKWL PROJECT_DATA=${PROJECT_DATA}
    else
      std_out "missing PROJECT_DATA assignment."
      std_out flush
      exit 1
    fi
  fi

  # Naming and placement of the base dirs in QA_RESULTS.
  # Inits also session-logs
  naming

  # change permissions
#  changeGroupPermission $QA_SRC
#  if [ "${QA_RESULTS:0:${#QA_WORK}}" != "$QA_WORK" ] ; then
#    changeGroupPermission $QA_RESULTS
#  fi

  # any error case happened before is written now
  if [ ${sendSubject} ] ; then
    std_out flush
    exit 1
  fi

  # check required directories, files and executables
  checkTools

  return
}

parseConfigurationFile()
{
  local confFile=$1

  local isBlockBeg=t
  local block

  if [ ${confFile} ] ; then
     if [ ! -e $confFile ] ; then
       return
     fi
  else
     return
  fi

  # now parse the configuration file.

  confLine=

  # Assignments from multiple lines infer their termination from
  # the next comment/blank line.
  # Reading lines happens in function parseLines (clear comments)

  # connect filename to input; keep it open for the while-loop
  exec 0< $confFile

  set -f

  while parseLines ; do
    if [ $isBlockBeg = t -a "${line}" ] ; then
      if findStr "$line" ':=' ; then
        # assignement of multi-line block.
        # Requires an empty or comment line underneath.
        isBlockBeg=f  # reset to true for a new- or comment-line
        line=${line/:=/=}
      fi

      block=
    fi

    # parsing for: key-word[=...]
    # find the key-word
    block=${block}${line}

    # read next line of a block
    test $isBlockBeg = f && continue

    # special: SELECT and LOCK syntax
    if [ "${block:0:6}" = 'LOCK+=' ] ; then
       sel_lock L ${block:4}
       continue
    elif [ "${block:0:5}" = 'LOCK=' ] ; then
       sel_lock L ${block:4}
       continue
    elif [ "${block:0:4}" = LOCK ] ; then
       # compatibility: multiple of such assignments are added
       if [ ${#pathList[*]} -eq 0 ] ; then
         sel_lock L =${block:4}
       else
         sel_lock L +=${block:4}
       fi
       continue
    fi

    if [ "${block:0:8}" = 'SELECT+=' ] ; then
       sel_lock S ${block:6}
       continue
    elif [ "${block:0:7}" = 'SELECT=' ] ; then
       sel_lock S ${block:6}
       continue
    elif [ "${block:0:6}" = SELECT ] ; then
       # compatibility: multiple of such assignments are added
       if [ ${#pathList[*]} -eq 0 ] ; then
         sel_lock S =${block:6}
       else
         sel_lock S +=${block:6}
       fi
       continue
    fi

    # assignment (blocks) are parsed
    parseKeyWordList
  done

  set +f
  # disconnect filename to input
  exec 0<&-

  return
}

naming()
{
  # A change in the placement of results.

  # QA_RESULTS will contain sub-dirs:
  # tables, data, check_logs,
  # and checksum; the latter only on request.
  # Sub-dir session_logs contains config, tasks, processing information.
  # As before, directory data/${PROJECT} will get the dir-tree spanned by
  # PROJECT_DATA=.*/project-name/dir-tree

  setKWL QA_RESULTS=$QA_RESULTS

  # the place for general log-messages
  initSession

  # sub-dir for experiment logs
  setKWL EXP_LOGDIR=${QA_RESULTS}/check_logs
  mkdir -p $EXP_LOGDIR

  if ! mkdir -p ${QA_RESULTS}/data ; then
    sendSubject='QA: initialisation error'
    std_out "Could not mkdir ${QA_RESULTS}/data. Exit."
    std_out flush
    exit 1
  fi

  # determine the final table paths

  # project table
  if [ ! ${TABLE_PATH} ] ; then
    TABLE_PATH=${QA_RESULTS}/tables
    test ! -d ${TABLE_PATH} && mkdir -p ${TABLE_PATH}
    setKWL TABLE_PATH=${TABLE_PATH}
  else
    # provided by configuration file
    # rm trailing '/'; does nothing, if such is not there
    TABLE_PATH=${TABLE_PATH%/}
  fi

  if [ ! -d "${TABLE_PATH}" ] ; then
    std_out "Expecting a directory ${TABLE_PATH}. Please, check the configuration file."
    std_out flush
    exit 1
  fi
}

parseKeyWordList()
{
   local key val tmp
   key=${block%%=*}

   if [ "$key" = "${block}" ] ; then
     val=
   else
     # Note: leading blanks have already been removed in parseLines()
     val="${block#*=}"   # remove ${key}=
   fi

   # compatibility
   if [ ${key} = IGNORE_REPLICATED_RECORDS ] ; then
      key=REPLICATED_RECORD
      val=ignore,${val/%,/}
   fi
   if [ ${key} = DISCARD_REPLICATED_RECORDS ] ; then
      key=REPLICATED_RECORD
      val=discard,${val/%,/}
   fi

   # allow RECORDS as well as RECORD (the latter will be used)
   pos=$(( ${#key} - 7 ))
   if [ "${key:pos}" = RECORDS ] ; then
     key=${key:0:$(( ${#key} -1 ))}
   fi

   # enable by just naming
   test ! ${val} && val=t

   setKWL ${key}="${val/%,/}"  # remove trailing ',', if present
   return
}

##//! Parse single lines of a configuration file

##/*!
## Discard comments and spaces.
##*/

parseLines()
{
  local line_
  local status
  unset line

  while : ; do
     # read a line
     read -r line_
     status=$?
     test ${status} -eq 1 -a ! "${line_}" && return 1

     # remove trailing comments from the line
     line_=$( expr match "$line_" '\([^#]*\)' )

     # in case of not empty, a non-comment-line was found
     test "${line_}" && break

     # reaching this indicates that a comment- or newline
     # was found

     if [ $isBlockBeg = f ] ; then
       # found the end of a block; process block
       isBlockBeg=t
       line=
       return 0
     fi
  done

  local i sz
  sz=${#line_}
  for((i=0 ; i < sz ; ++i )) ; do
    test "${line_:i:1}" = '=' && break
  done

  if [ ${i} -eq ${sz} ] ; then
    line_="${line_//QC/QA}"
  else
    local tmp0="${line_:0:i}"
    tmp0="${tmp0//QC/QA}"
    line_="${tmp0}""${line_:i}"
  fi

  # we'd like to remember effective lines in the conf file
  confLine=${confLine}"${line_}"\\n

  # replace accidently used key-word: LOCKED or SELECTED
  test "$( echo -n "${line_:0:6}" \
     | tr [:lower:] [:upper:])" = "LOCKED" \
       && line_="LOCK${line_:6}"

  test "$( echo -n "${line_:0:8}" \
     | tr [:lower:] [:upper:])" = "SELECTED" \
       && line_="SELECT${line_:8}"

  # remove blanks from line
  line="${line_// /}"

  return 0
}

##//! Parse command-line options.

parseOPTARG()
{
  local key value

  key=${1%%=*}
  if [ "${1}" = "${1/=/}"  ] ; then
    value=t
  else
    value=${1#*=}
  fi

  if [ "${key}" = "ADD_PROG_ARG" ] ; then
    ADD_PROG_ARG=( ${ADD_PROG_ARG[*]} ${value} )
    keyWordList[${#keyWordList[*]}]=ADD_PROG_ARG
    return
  fi

  if [ "${key}" = "CHECK_TOOLS" ] ; then
    CHECK_TOOLS=t
    checkTools
    exit 1
  fi

  test "${key}" = CYCLE && \
    setKWL CYCLE=${value:-1} && return

  if [ "${key:0:7}" = DEBUG_C ] ; then
    set -x
    return
  fi

  test "${key:0:7}" = DEBUG_E && \
    setKWL DEBUG_EXECUTOR=t && return

  if [ "${key:0:7}" = DEBUG_M ] ; then
    installArgs="${installArgs}--debug,"
    setKWL DEBUG_MANAGER=${value:-t}
    return
  fi

  if [ "${key}" = NEXT ] ; then
    test ${value} = t && value=1
    setKWL NEXT=${value} && return
  fi

  test "${key}" = SHOW_OPT && \
    displayComLineOptions 'dumb' && exit 1

  test "${key}" = SHOW_NEXT && \
    setKWL SHOW_NEXT=${value:-0} && return

  if [ "${key}" = NOTE ] ; then
    for(( i=0 ; i < ${#keyWordList[*]} ; ++i )) ; do
      if [ "${key}" = ${keyWordList[i]} ] ; then
        NOTE="${value}","${NOTE[*]// /,}"
        return
      fi
    done

  elif [ "${key}" = OUTLIER_TEST ] ; then
    for(( i=0 ; i < ${#keyWordList[*]} ; ++i )) ; do
      if [ "${key}" = ${keyWordList[i]} ] ; then
        OUTLIER_TEST="${value}","${OUTLIER_TEST[*]// /,}"
        return
      fi
    done

  elif [ "${key}" = QA_HOME ] ; then
    installArgs="${installArgs}QA_HOME=${OPTARG#*=},"
  fi

  # no more syntax checks; invoke all
  setKWL ${key}=${value}

  return
}

##//! parse SELECT and LOCK assignments
sel_lock()
{
  # Note for SELECT, LOCK, -S and -L usage:
  # General setting:  {space, = ,+=}[path[=]][variable]

  # Examples:
  # leading character(s) supplied by the calling instances
  # -) '=' define or overwrite
  # -) '+=' prolong array of paths/variables
  # -) no leading '=' character equivalent to +=
  # -) not a path: variable(s) to path '.*', e.g. by -S var
  # -) contains '/', thus equivalent to 3)

  # 1) path=var
  #    specifies a single path where to look for a single variable
  # 2) p1,p2=var
  #    two paths to look for a variable
  # 3) p1,p2=
  #    two paths with every variable, equivalent to p1,p2=.*
  # 4) p1=v1,v2
  #    one path with two variables
  # 5) str1[,str2,str3]
  #    a) no '/' --> variables
  #    b) '/' anywhwere  --> only paths; no trapping of errors
  # 6) relative path without a '/' must have '=' appended
  # 7) p1=,p2=v1...  --> ERROR


  local i p v z

  # this is very special: a fully qualified file
  if [ -f $2 ] ; then
    z=${2%/*}=${2##*/}
  elif [ -f ${2:1} ] ; then
    z=${2%/*}=${2##*/}
  else
    z=$2
  fi

  while : ; do
    if [ ${z:0:1} = '=' ] ; then
      if [ $1 = S ] ; then
        pathList=
        varList=
      elif [ $1 = L ] ; then
        lockPathList=
        lockVarList=
      fi

      z="${z:1}"
    elif [ ${z:0:2} = '+=' ] ; then
      z=${z:2}
    elif [ ${z//=/} = ${z} -a ${z//\//} != ${z} ] ; then
#     z=${z}= # 7b), thus again
      break
    else
      if [ $1 = S ] ; then
        # only variable, no path
        if [ ${#pathList[*]} -gt 0 -a "${z//=/}" = "${z}" ] ; then
          z="${pathList[$((${#pathList[*]} -1 ))]}=${z}"
          pathList=
          varList=
        fi
      elif [ $1 = L ] ; then
        if [ ${#lockPathList[*]} -gt 0 -a "${z//=/}" = "${z}" ] ; then
          z="${lockPathList[$((${#lockPathList[*]} -1 ))]}=${z}"
          lockPathList=
          lockVarList=
        fi
      fi
    fi

    break;
  done;

  # now assignment mode is determined; parse on
  v=${z#*=}
  p=${z%=*}

  # no path, but only variable?
  if [ "$p" = "$v" ] ; then
    # test for a slash
    if [ "${p/\/}" = "${p}" ] ; then
      # no path; only variable
      p='.*'
    else
      v='.*'
    fi
  elif [ ${#p} -eq 0 -a ${#v} -gt 0 ] ; then
      # no path; only variable
      p='.*'
  elif [ ${#p} -gt 0 -a ${#v} -eq 0 ] ; then
      # no variable; only path
      v='.*'
  elif [ ${#v} -eq 0 ] ; then
    # there is only a path, but no explicit variable
    v='.*'
  fi

  # path and variable

  # multiple, comma-separated paths?
  local j pp vv
  pp=( ${p//,/ } )
  vv=( ${v//,/ } )
  p=()
  v=()

  for(( i=0 ; i < ${#pp[*]} ; ++i )) ; do
    for(( j=0 ; j < ${#vv[*]} ; ++j )) ; do
      p[${#p[*]}]=${pp[i]}
      v[${#v[*]}]=${vv[j]}
    done
  done

  # selection or a lock?
  if [ $1 = 'S' ] ; then
    pathList=( ${pathList[*]} ${p[*]} )
    varList=( ${varList[*]} ${v[*]} )
  elif [ $1 = 'L' ] ; then
    lockPathList=( ${lockPathList[*]} ${p[*]} )
    lockVarList=( ${lockVarList[*]} ${v[*]} )
  fi

  return
}

sendEMail()
{
  if [ ${#EMAIL_TO[*]} -eq 0 ] ; then
    sendText=
    sendSubject=
    return
  fi

  # activate backslash escaped chars
  sendText="$( echo -e $sendText )"

  eval ${MAIL} -s \"\$sendSubject\"  ${EMAIL_TO[*]} <<!
$sendText
!

  sendText=
  sendSubject=

  return
}

sendInitEMail()
{
  # activate backslash escaped chars
  sendText="$( echo -e $sendText )"

  eval ${MAIL} -s "$sendSubject"  ${EMAIL_TO[*]} <<!
$sendText

Configuration File Setting:
$( echo -e $confLine )

Command-line parameters:
$( echo "${comLine[*]}" )

Current Paths:
Source directory: $QA_SRC
QA data directory: $QA_RESULTS/data
FS data directory: ${PROJECT_DATA[*]}
!

  # this is required at some places
  sendText=
  sendSubject=

  return
}


##//! Convert assignment literals to Bash variables.

setKWL()
{
  test ${DEBUG_CONF} && voidX

  local key item value i val vals isAdd
  item="$*"

  for(( i=0 ; i < ${#item} ; ++i )) ; do
     if [ "${item:i:1}" = '+' ] ; then
        isAdd=t
        key="${item%%+=*}"

        break
     fi
     if [ "${item:i:1}" = '=' ] ; then
        isAdd=f
        key="${item%%=*}"
        break
     fi
  done

  key=$( echo "${key/% /}" | tr "[:lower:]" "[:upper:]" )
  if [ ${key} ] ; then
    value="${item#*=}"
  else
    key="${item#*=}"
    value=t
  fi

  # disable --> f
  test "${value:0:7}" = disable && value=f

  # take deprecated SHOW_EXP_NAME into account
  test "${key:0:8}" = SHOW_EXP && key=SHOW_EXP
  test "${key}" = HIDDEN_DIRECTORY_DESCENT && key=HIDDEN_DIRECTORIES

#  eval ${key}="${value// /\\ /}"

  # special: QA_BIN
  if [ "$key" = QA_BIN ] ; then
    value=${value%/}  # rm a trailing '/'
    vals=( ${value//,/ } )
    local host hosts
    for(( i=0 ; i < ${#vals[*]} ; ++i )) ; do
      val=${vals[i]}
      if [ "${val#*:}" = "${val}" ] ; then
        hosts[i]=''
      else
        hosts[i]="${val%:*}:"
      fi
      val=${val#*:}
      test "${val}" != "${vals[i]}" && vals[i]=${val}
    done

    # rearrange the array: the bin-dir of HOSTNAME is set
    # to the first position.
    for(( i=0 ; i < ${#vals[*]} ; ++i )) ; do
       if [ "${hosts[i]}" = "${HOSTNAME}:" \
                -o  ${#hosts[i]} -eq 0 ] ; then
         if [ $i -eq 0 ] ; then  # right order
           hosts[0]=''
           break
         fi

         local tmp
         tmp="${hosts[0]}"
         hosts[0]="${hosts[i]}"
         hosts[i]=$tmp

         tmp="${vals[0]}"
         vals[0]="${vals[i]}"
         vals[i]=$tmp

         break
       fi
    done

    QA_BIN=
    # convert relative paths to abolute ones
    test "${vals[0]:0:1}" != '/' && vals[0]=${QA_SRC}/${vals[0]}
    QA_BIN[0]=${vals[0]}

    for(( i=1 ; i < ${#vals[*]} ; ++i )) ; do
      # convert relative paths to abolute ones
      test "${vals[i]:0:1}" != '/' && vals[$i]=${QA_SRC}/${vals[i]}

      QA_BIN[${#QA_BIN[*]}]=${hosts[i]}${vals[i]}
    done
    value="${QA_BIN[*]}"
    value=${value// /,}
    unset QA_BIN

    # to be applied within this script
    curr_QA_BIN=${value%%,*}
  fi

  # was key already defined?
  for(( i=0 ; i < ${#keyWordList[*]} ; ++i )) ; do
     if [ "${keyWordList[i]}" = "$key" ] ; then

      # plain assignments require to unset before reassignments
      if [ $isAdd = f ] ; then
#        eval unset $key
        eval ${key}=${value}
      else
        tmp=${keyWordList[i]}
        eval $key=\${$tmp},${value// /\\ }
      fi

      test ${DEBUG_CONF} && voidX
      return 0
    fi
  done

  # new key
  eval ${key}="${value}"

  # add key to the list
  keyWordList[${#keyWordList[*]}]=$key

  test ${DEBUG_CONF} && voidX
  return 0
}

std_out()
{
  # if a tty device is connected, then output immediately,
  # else collect contents and print to a default file and/or
  # send by email.

  test $# -eq 0 && return

  if [ "$1" = ttyOnly ] ; then
    if is_TTY ; then
       shift
       echo -e -n "$*" > $TTY
    fi
    return
  fi

  if [ "$1" = flush ] ; then
    local j str0

    test ${#outputText[*]} -eq 0 && return

    if [ ${#EMAIL_TO[*]} -gt 0 ] ; then
      for(( j=0 ; j < ${#outputText[*]} ; ++j )) ; do
        # each item begins with \n
        sendText="${sendText}\n${outputText[j]}"
      done
      if [ ! ${sendSubject} ] ; then
        sendSubject="qaConfiguration: message"
      fi
      sendEMail
    elif [ ! ${SESSION_LOGDIR} ] ; then
      str0="$( date +'%F %T' ) ${HOSTNAME%%.*}:qaConfiguration"
      echo -e "\n${str0}" >> $SESSION_LOGDIR/session.log

      for(( j=0 ; j < ${#outputText[*]} ; ++j )) ; do
        echo -e "${outputText[j]}" >> $SESSION_LOGDIR/session.log
      done
    else
      # str0 gets the filename for undeliverables
      str0="undeliv_$( date +'%FT%T' )_${HOSTNAME%%.*}".txt
      if mkdir -p $QA_SRC/NoDevice &> /dev/null ; then
        for(( j=0 ; j < ${#outputText[*]} ; ++j )) ; do
          echo -e "${outputText[j]}" >> $QA_SRC/NoDevice/$str0
        done
      fi
    fi
  else
    if [ -c "${TTY}" ] ; then # character device is open?
      echo -e "$*" > $TTY
    else
      outputText[${#outputText[*]}]="$*"
    fi
  fi
}

tryExist()
{
  test ${DEBUG_CONF} && voidX

  # if test fails, then something is written to sendText

  # $1:   'dir' | 'file' | 'com'
  # $2:    name of directory, file or command
  # $3:   key-word: 'compile' ; default: scan the path for the command.
  # $3:   key-word: 'void' ; return -1 without notification.

  #return 0 ==> exists
  #return 1 ==> no

  if [ "$1" = 'dir' ] ; then
    if [ ! -d $2 ] ; then
      sendText="${sendText}\nDirectory $1 not found."
      return 1
    fi

    test ${DEBUG_CONF} && voidX
    return 0
  fi

  if [ "$1" = 'file' ] ; then
    if [ ! -e $2 ] ; then
      sendText="${sendText}\nFile $1 not found."
      return 1
    fi

    test ${DEBUG_CONF} && voidX
    return 0
  fi

  if [ "$1" = 'com' ] ; then
    if which ${curr_QA_BIN#*:}/$2 &>/dev/null ; then
      return 0
    elif [ "$3" != 'compile' ] ; then
      if which $2 &>/dev/null ; then
        test ${DEBUG_CONF} && voidX
        return 0
      fi
      test "$3" != 'void' && \
         sendText="${sendText}\n command $2 not found."
      test ${DEBUG_CONF} && voidX
      return 1
    fi

    # try a C compilation
    if [ -e ${QA_SRC}/src/${2%.x}.c ] ; then
      if [ ! ${CC} ] ; then
        sendText="${sendText}\nC compiler not found."
        test ${DEBUG_CONF} && voidX
        return 1
      fi

      local answ status
      answ=$( $CC ${CFLAGS[*]} -o ${curr_QA_BIN#*:}/$2 \
          ${QA_SRC}/src/${2%.x}.c )

      status=$?
      if [ ${status} -eq 0 ] ; then
        return 0
      else
        sendText="${sendText}\n${answ}"
        test ${DEBUG_CONF} && voidX
        return 1
      fi

    # try a C++ compilation
    elif [ -e ${QA_SRC}/src/${2%.x}.cpp ] ; then
      if [ ! ${CXX} ] ; then
        sendText="${sendText}\nC++ compiler not found CXX=${CXX}."
        test ${DEBUG_CONF} && voidX
        return 1
      fi

      local answ status
      answ=$( $CXX ${CPPFLAGS[*]} -o ${curr_QA_BIN#*:}/$2 \
          ${QA_SRC}/src/${2%.x}.cpp &> /dev/null )

      status=$?
      if [ ${status} -eq 0 ] ; then
        test ${DEBUG_CONF} && voidX
        return 0
      else
        sendText="${sendText}\n${answ}"
        test ${DEBUG_CONF} && voidX
        return 1
      fi
    else
      if [ ! -e ${curr_QA_BIN#:*}/$2 ] ; then
        sendText="${sendText}\n${2%.x}.c|cpp not found in ${QA_SRC}/src."
        sendText="${sendText} No compilation."
        test ${DEBUG_CONF} && voidX
        return 1
      fi

      test ${DEBUG_CONF} && voidX
      return 0  # ok
    fi

    std_out 'qaConfiguration:tryExist() we never shall arrive here'
    std_out flush
    exit 1
  fi

  test ${DEBUG_CONF} && voidX
  return
}

tr_option()
{
  test ${DEBUG_CONF} && voidX

  local line="${!1}"

  local sz i
  local sz=${#line}
  for((i=0 ; i < sz ; ++i )) ; do
    test "${line:i:1}" = '=' && break
  done

  if [ ${i} -eq ${sz} ] ; then
    if [ ${i} -eq 2 -a ${i:0:1} = '-' ] ; then
      :
    else
     line=$( echo "${line/% /}" | tr "[:lower:]" "[:upper:]" )
     line=$( echo "${line}" | tr "-" "_" )
    fi
  else
    local tmp0="${line:0:i}"
    tmp0="${tmp0//QC/QA}"
    tmp0=$( echo "${tmp0/% /}" | tr "[:lower:]" "[:upper:]" )
    tmp0=$( echo "${tmp0}" | tr "-" "_" )
    line="${tmp0}""${line:i}"
  fi

  eval ${1}=\${line}

  test ${DEBUG_CONF} && voidX
  return
}

unsetKWL()
{
  test ${DEBUG_CONF} && voidX

  local key
  item="$*"

  key=$( echo "${item}" | tr "[:lower:]" "[:upper:]" )

  # was key already defined?
  local i
  for(( i=0 ; i < ${#keyWordList[*]} ; ++i )) ; do
     if [ "${keyWordList[i]}" = "$key" ] ; then

      # plain assignments require to unset before reassignments
      eval unset $key
      unset keyWordList[$i]
      break
    fi
  done

  test ${DEBUG_CONF} && voidX
  return
}

voidX()
{
  # toggle between set -x and set +x in a way that
  # restores the original setting after having been called twice

  if [ ${isSetX:-t} = t ] ; then
    test "$(set -o |grep xtrace | awk '{print $2}')" = off && return

    # first call
    isSetX=on
  fi

  # restore previous setting
  if [ ${isSetX} = off ] ; then
    set -x
    isSetX=on
  else
    set +x
    isSetX=off
  fi

  return
}

##main()
##{

# ############### main ###############
umask 002

# called by qa-DKRZ with identical path
# get execution path of QA scripts
getQA_SRC $0
getCurrPaths

# very specific: convert -E_SELECT or -E_LOCK into -S or -L respectively.
# Also, accept -E_SELECT param or -E_LOCK param, i.e. separated by a space
for(( i=1 ; i <= $# ; ++i )) ; do
  item=${!i}
  tr_option item

  arg=

  if [ ${item:0:9} = '-E_SELECT' -o ${item:0:7} = '-E_LOCK' ] ; then
    j=$((i+1))
    if [ ${item#*=} != ${item} ] ; then
       arg="-${item:3:1} ${item#*=}"  # prefixed by -S or -L followed by arg
    elif [ ${!j:0:1} != '-' ] ; then
       arg="-${item:3:1} ${!j}"
       j=$((j+1))
    fi
  fi

  if [ ${arg} ] ; then
     set -- ${*:1:$((i-1))} ${arg} ${*:j}
     arg=
  fi
done

# stage 0: scan for configuration files etc.
while getopts :d:D:e:E:f:hmP:QqL:S:s:T:Vx-: option
do
  UOPTARG=${OPTARG}
  tr_option UOPTARG

  case $option in
  e|E)  if [ ${UOPTARG:0:8} = '_DEBUG_C' ] ; then
          DEBUG_CONF=t
          set -x
        elif [ ${UOPTARG:0:9} = '_PROJECT=' ] ; then
          setKWL ${UOPTARG:1}
        elif [ ${UOPTARG:0:11} = '_PROJECT_AS=' ] ; then
          setKWL ${UOPTARG:1}
        fi
        ;;
    f)  qaConf[${#qaConf[*]}]=${OPTARG}
        test ! -f ${OPTARG} && noSuchFile=( ${noSuchFile[*]} ${OPTARG} )
        ;;
    h)  isHelp=t ;;
    P)  setKWL PROJECT=$OPTARG ;;
    T)  TTY=${OPTARG} ;;
    x)  set -x
        ;;
    -)  test "$OPTARG" = "help" && isHelp=t && continue
        test "${UOPTARG%=*}" = "PROJECT_AS" && setKWL PROJECT_AS=${OPTARG#*=} && continue
        ;;
   \?)  ;;
  esac
done

if [ ${isHelp:-f} = t ] ; then
  descript
  exit 1
fi

if [ ${noSuchFile} ] ; then
  for nsf in ${noSuchFile[*]} ; do
    test -c "$TTY" && echo "${nsf}: no such file" > $TTY
  done

  exit 1
fi

# may be overwritten by configuration file or command-line
setDefaults

# get valid configuration files corresponding to the priority list
getPrecedence ${qaConf[*]}

# construct a comma-sep-list
if [ ${#filePrecedence[*]} -gt 0 ] ; then
  QA_CONFS="${filePrecedence[*]}"
  QA_CONFS="${QA_CONFS// /,}"

  setKWL TASK=${filePrecedence[0]##*/}
fi

# proceed from low to high priority
for(( i=${#filePrecedence[*]}-1 ; i > -1 ; --i )) ; do
  parseConfigurationFile ${filePrecedence[i]}
done

if [ ${PROJECT} ] ; then
  test ! ${PROJECT_AS} && setKWL PROJECT_AS=${PROJECT}
else
  if [ ${PROJECT_AS} ] ; then
    setKWL PROJECT=${PROJECT_AS}
  else
    setKWL PROJECT=NONE
    setKWL PROJECT_AS=NONE
  fi
fi

# command-line overwrites configuration file assignments
comLine=( $* ) # for e-mail and initSession

test ${QA_CONFS} && setKWL QA_CONF=${QA_CONFS}

# look for multiple occurrences; pass command-line notes as parameter
for(( i=0 ; i < ${#comLine[*]} ; ++i )) ; do
  cL=${comLine[i]:3}
  test ! ${cL} && continue

  tr_option cL

  if findStr ${cL} NOTE ; then
    comLineNotes[${#comLineNotes[*]}]="${cL}"
  fi
done

getMultiLists ${comLineNotes[*]}

# Note: option -T is used internally, when the qa-DKRZ
#       executes the qaConfiguration script.
set -f

# stage1
unset OPTIND
while getopts d:D:e:E:f:hmP:QqL:S:s:T:x-: option
do
  UOPTARG=$OPTARG
  tr_option UOPTARG

  case $option in
    d|D) # disable previously enabled options
         unsetKWL ${OPTARG} ;;
    e|E) # Enable features or set parameters
        test ${UOPTARG:0:8} != '_DEBUG_C' && parseOPTARG ${UOPTARG:1}
        ;;
    f)  # already done
        ;;
    h)  # already done
        exit 1  ;;
    L)  sel_lock L ${OPTARG}
        set +f
        ;;
    m)  setKWL SIMPLE_STATUS_LINE=t ;;
    P)  setKWL PROJECT=$UOPTARG ;;
    Q)  setKWL NO_STATUS=t ;;
    q)  setKWL QUIET=t ;;
    S)  sl_args=( ${OPTARG//,/} )
        ;;
    s)  setKWL SESSION_DATE=${OPTARG} ;;
    T)  # already caught
        ;;
    x)  setKWL DEBUG_MANAGER=t
        setKWL DEBUG_EXECUTOR=t
        ;;  # already done for this script
    -)  if [ "$OPTARG" = "help" ] ; then
          descript
          exit 1

        elif [ "${UOPTARG%=*}" = "AUTO_UP" ] ; then
          installArgs="${installArgs}--auto-up=${optarg#*=},"

        elif [ "${UOPTARG%=*}" = "AUTO_TABLE_UP" ] ; then
          installArgs="${installArgs}--auto-table-up=${optarg#*=},"

        elif [ "${UOPTARG:0:5}" = DEBUG ] ; then
          set -x
          if [ ${#OPTARG} -eq 5 -o ${OPTARG#*=} = qa-parse-config ] ; then
            installArgs="${installArgs}--debug,"
            setKWL DEBUG_MANAGER=t
          else
            installArgs="${installArgs}--debug=${OPTARG#*=},"
          fi

        elif [ "${UOPTARG:0:7}" = EXAMPLE ] ; then
          setKWL QA_EXAMPLE=t
          if [ ${OPTARG} != ${OPTARG#*=} ] ; then
            setKWL EXAMPLE_PATH=${OPTARG#*=}
          fi

        elif [ "${OPTARG:0:4}" = fpid ] ; then
          setKWL FORMER_PID=$OPTARG

        elif [ "$OPTARG" = "help" ] ; then
          : # done before
        elif [ "${UOPTARG%=*}" = "PROJECT_AS" ] ; then
          : # done before

        elif [ "${OPTARG:0:2}" = pb ] ; then
          if [ ${OPTARG} = ${OPTARG#*=} ] ; then
            setKWL PROGRESS_BAR=t
          else
            setKWL PROGRESS_BAR=${OPTARG#*=}  # file to write to
          fi

        elif [ "${UOPTARG%=*}" = SET_DEFAULT_PROJECT ] ; then
          installArgs="${installArgs}--set_default_project=${OPTARG#*=},"

        elif [ "${UOPTARG:0:4}" = WORK ] ; then
          installArgs="${installArgs}QA_HOME=${OPTARG#*=},"
          setKWL QA_HOME=${OPTARG##*=}

        else
          echo "invalid option --${OPTARG}" > /dev/stderr
#          descript
          exit 1
        fi
        ;;
   \?)  #descript
        exit 1;;
  esac
done

test ${installArgs} && setKWL INSTALL_ARGS=${installArgs}

shift $(( $OPTIND - 1 ))

# for downward compatibility
test ${QA_DATA_ROOT} && setKWL QA_RESULTS=${QA_DATA_ROOT}
test ${DATA_ROOT_FS} && setKWL PROJECT_DATA=${DATA_ROOT_FS}

if [ $# -gt 0 ] ; then
  # any valid files specified on the command-line
  fs=()
  for f in $* ; do
    if [ -f $f  ] ; then
      if [ $f = ${f#*/} ] ; then
        fs[${#fs[*]}]=${pwd}/$f
      else
        fs[${#fs[*]}]=$f
      fi
    fi
  done

  sl_args=( ${sl_args[*]} ${*//,/ } )
fi

set +f

# almost everything is done here
loadSetting

# Return the configuration and selected experiments
# and parameters to the calling director.

set -f

# selection on the command-line cancels any selection in config-files
if [ ${sl_args} ] ; then
  for(( i=0 ; i < ${#sl_args[*]} ; ++i )) ; do
    if [ ${sl_args[i]:0:1} = '/' ] ; then
      # rule: if absolute path on cmd-line, then cancel previous
      unsetKWL PROJECT_DATA

      pathList=
      varList=
    else
      if [ ${sl_args[i]/=/} = ${sl_args[i]} ] ; then
        # only variables; no path components
        for(( j=0 ; j < ${#pathList[*]} ; ++j )) ; do
          varList[j]=${sl_args[i]}
        done
        continue
      fi
    fi

    sel_lock S ${sl_args[i]}
  done
fi

# NOTE: arrays of experiments and parameters are provided
#       by the file LOGIDR/cache_request_SESSION.txt

# Synchronise QA_EXEC_HOSTS and NUM_EXEC_THREADS
if [ ${#NUM_EXEC_THREADS[*]} -lt ${#QA_EXEC_HOSTS[*]} ] ; then
  myLastPos=$(( ${#NUM_EXEC_THREADS[*]} -1 ))
  myLastNum=${NUM_EXEC_THREADS[myLastPos]}
  for(( j=myLastPos+1 ; j < ${#QA_EXEC_HOSTS[*]} ; ++j )) ; do
    NUM_EXEC_THREADS[j]=$myLastNum
    # add key to the list
  done

  keyWordList[${#keyWordList[*]}]=NUM_EXEC_THREADS
fi

# sort and remove duplicates
# Note: echo add a blank between items
#       thus, the leading blank in the "" expression is required.
keyWordList=( $(echo -e " ${keyWordList[*]/%/\\n}" | sort -b | uniq ) )

test ${unset_PD:-f} = t && unsetKWL PROJECT_DATA

# Prepare the settings as key=val, where val could also be an array.
for key in ${keyWordList[*]} ; do
  test QA_DATA_ROOT = ${key} && continue
  test DATA_ROOT_FS = ${key} && continue
  test QA_PROJECT   = ${key} && continue

  eval val=( \${${key}[*]} )
  test ${val} &&  array[${#array[*]}]=${key}=${val[*]}
done

# remove duplicates
pathList=( ${pathList[*]//,/ } )
varList=( ${varList[*]//,/ } )
for(( i=0 ; i < ${#pathList[*]} -1 ; ++i )) ; do
  for(( j=i+1 ; j < ${#pathList[*]} ; ++j )) ; do
    if [ "${varList[i]} = "${varList[j]} ] ; then
      if [ "${pathList[i]} = "${pathList[j]} ] ; then
         unset pathList[$j]
         unset varList[$j]
      fi
    fi
  done
done
pathList=( ${pathList[*]} )
varList=( ${varList[*]} )

# special treatmeant to preserve regExp
if [ ${pathList} ] ; then
  array[${#array[*]}]=SELECT_PATH_LIST="${pathList[*]//,/ }"
  array[${#array[*]}]=SELECT_VAR_LIST="${varList[*]//,/ }"
fi

# special treatmeant to preserve regExp
if [ ${lockPathList} ] ; then
  array[${#array[*]}]=LOCK_PATH_LIST="${lockPathList[*]//,/ }"
  array[${#array[*]}]=LOCK_VAR_LIST="${lockVarList[*]//,/ }"
fi

# display all assignments made
if [ ${SHOW_CONF:-f} = t ] ; then
  for(( j=0 ; j < ${#array[*]} ; ++j )) ; do
    std_out ${array[j]}
  done

  std_out flush
  test ${SHOW_EXP:-f} = f && exit 1
fi

# Submit the setting to the caller
# It is necessary to change the field separator to keep embedded arrays distinct.
IFS='%'

for(( j=0 ; j < ${#array[*]} ; ++j )) ; do
  echo -n "${array[j]}%"
done

std_out flush

##}
